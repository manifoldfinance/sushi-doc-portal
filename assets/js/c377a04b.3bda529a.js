"use strict";(self.webpackChunk_sushiswap_kitchen_docs=self.webpackChunk_sushiswap_kitchen_docs||[]).push([[6971],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>c});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=a.createContext({}),d=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=d(e.components);return a.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),h=d(n),c=o,m=h["".concat(s,".").concat(c)]||h[c]||u[c]||i;return n?a.createElement(m,r(r({ref:t},p),{},{components:n})):a.createElement(m,r({ref:t},p))}));function c(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,r=new Array(i);r[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:o,r[1]=l;for(var d=2;d<i;d++)r[d]=n[d];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},1269:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>u,frontMatter:()=>i,metadata:()=>l,toc:()=>d});var a=n(7462),o=(n(7294),n(3905));const i={title:"Sushiswap Incentives",created:"2022-03-09T03:32:29 (UTC -08:00)",tags:["masterchef","sushiswap"],version:"latest"},r="Sushiswap Platform",l={unversionedId:"index",id:"index",title:"Sushiswap Incentives",description:"SushiSwap is an automated market-making (AMM) decentralized exchange (DEX)",source:"@site/docs/index.md",sourceDirName:".",slug:"/",permalink:"/docs/",editUrl:"https://github.com/manifoldfinance/sushi-doc-portal/edit/master/docs/index.md",tags:[{label:"masterchef",permalink:"/docs/tags/masterchef"},{label:"sushiswap",permalink:"/docs/tags/sushiswap"}],version:"current",lastUpdatedBy:"sam bacha",lastUpdatedAt:1647917218,formattedLastUpdatedAt:"3/22/2022",frontMatter:{title:"Sushiswap Incentives",created:"2022-03-09T03:32:29 (UTC -08:00)",tags:["masterchef","sushiswap"],version:"latest"},sidebar:"myAutogeneratedSidebar",previous:{title:"Sushi Contracts Deployments",permalink:"/docs/deployments"},next:{title:"getting-started",permalink:"/docs/kashi/getting-started"}},s={},d=[{value:"MasterChef",id:"masterchef",level:3},{value:"Variables",id:"variables",level:2},{value:"Init",id:"init",level:2},{value:"Add",id:"add",level:2},{value:"Set",id:"set",level:2},{value:"Update Pool",id:"update-pool",level:2},{value:"Pending Sushi",id:"pending-sushi",level:2},{value:"Deposit",id:"deposit",level:2},{value:"Withdraw",id:"withdraw",level:2},{value:"Harvest",id:"harvest",level:2},{value:"Sushi Per Block",id:"sushi-per-block",level:2},{value:"External Rewards",id:"external-rewards",level:2},{value:"Reward Token",id:"reward-token",level:2},{value:"Harvest From MCV1",id:"harvest-from-mcv1",level:2}],p={toc:d};function u(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"sushiswap-platform"},"Sushiswap Platform"),(0,o.kt)("p",null,"SushiSwap is an automated market-making (AMM) decentralized exchange (DEX)\ncurrently on the Ethereum blockchain. In addition to DEX, SushiSwap involves a\ncollection of governance, operations and reward contracts that help grow the\nSushiSwap ecosystem and utilization."),(0,o.kt)("h3",{id:"masterchef"},"MasterChef"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Double Incentives; MasterChefV2")),(0,o.kt)("p",null,"The MasterChef contract gives out a constant number of SUSHI per Block. It is\nthe only address with minting rights for the SUSHI token. Therefore any\nincentive mechanism must be based upon that contract. The idea for this\nMasterChef V2 (MCV2) contract is therefore to be the owner of a dummy token that\nis deposited into the MasterChef V1 (MCV1) contract. The allocation point for\nthis pool on MCV1 is the total allocation point for all pools that receive\ndouble incentives."),(0,o.kt)("p",null,"The distribution logic from MCV1 is taken over and simplified with the key\ndifferentiator that the allocation of SUSHI for all pools is calculated through\nthe allocation towards the master pool on MCV1 instead of being a constant."),(0,o.kt)("p",null,"Reward Contracts are set at Pool Addition, all Logic is executed on those."),(0,o.kt)("p",null,"Instead of doing token transfers on deposit and withdrawal, instead, the\nrewardDebt is changed accordingly. As it now is allowed to go negative, it is\nchanged to a signed integer. The appropriate version of SignedSafeMath is used\nwith an additional safe conversion to uint256."),(0,o.kt)("h2",{id:"variables"},"Variables"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"UserInfo")," should only be changed for ",(0,o.kt)("inlineCode",{parentName:"p"},"msg.sender")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"amount")," How many LP tokens the user has provided, should be equal to\n",(0,o.kt)("inlineCode",{parentName:"p"},"lp.balanceOf(user)")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"rewardDebt")," keeps track of how much the user is owed or has been credited\nalready"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"PoolInfo")," keeps information on LP position"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"accSushiPerShare")," Accumulated SUSHIs per share, times 1e12."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"allocPoint")," How many allocation points assigned to this pool"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"lastRewardBlock")," Last block number that SUSHIs distribution occurs."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"MasterChef")," address of MasterChef contract\n(",(0,o.kt)("inlineCode",{parentName:"p"},"0xc2EdaD668740f1aA35E4D8f227fB8E17dcA888Cd"),")"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"sushi")," address of sushi contract (",(0,o.kt)("inlineCode",{parentName:"p"},"0x6b3595068778dd592e39a122f4f5a5cf09c90fe2"),")"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"MASTER_PID")," pool id of dummy Token on MasterChef V1"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"totalAllocPoint")," Total allocation points. Must be the sum of all allocation\npoints in all pools."),(0,o.kt)("p",null,"The following arrays should be accessed by the same index ",(0,o.kt)("inlineCode",{parentName:"p"},"pid")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"PoolInfo[] public poolInfo")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"IRewarder[] public rewarder")),(0,o.kt)("h2",{id:"init"},"Init"),(0,o.kt)("p",null,"Pulls the balance of the dummyToken from ",(0,o.kt)("inlineCode",{parentName:"p"},"msg.sender")," and deposit it in\nMasterChef V1 in the dummy token pool."),(0,o.kt)("h2",{id:"add"},"Add"),(0,o.kt)("p",null,"Adds a reward pool for a specified LP Token with an allocation point and a\nrewarder contract by adding to the ",(0,o.kt)("inlineCode",{parentName:"p"},"poolInfo")," , ",(0,o.kt)("inlineCode",{parentName:"p"},"rewarder")," und ",(0,o.kt)("inlineCode",{parentName:"p"},"lpToken")," array."),(0,o.kt)("p",null,"Emits the Index of the newly added pool (",(0,o.kt)("inlineCode",{parentName:"p"},"pid"),") among the above parameter."),(0,o.kt)("h2",{id:"set"},"Set"),(0,o.kt)("p",null,"Updates the given pools identified by the array index ",(0,o.kt)("inlineCode",{parentName:"p"},"pid")," with a new\nallocation point and changes the rewarder contract if ",(0,o.kt)("inlineCode",{parentName:"p"},"overwrite")," is true."),(0,o.kt)("h2",{id:"update-pool"},"Update Pool"),(0,o.kt)("p",null,"Update reward variables of the given pool to be up-to-date."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"accSushiPerShare")," is the accumulated amount of Sushi per share of this pool and\nincreased by the difference of ",(0,o.kt)("inlineCode",{parentName:"p"},"block.number")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"lastRewardBlock")," times the\npercentage the MasterChefV2 pool has in MCV1 and the percentage this pool has in\nMCV2 times the constant emission of SUSHI per block (100) divided by the number\nof LP tokens in this pool."),(0,o.kt)("h2",{id:"pending-sushi"},"Pending Sushi"),(0,o.kt)("p",null,"Calculates the amount of Sushi a given user can harvest from a given pool. The\namount of sushi for a user is the number of LP token a user has in this pool\n(",(0,o.kt)("inlineCode",{parentName:"p"},"user.amount"),") times ",(0,o.kt)("inlineCode",{parentName:"p"},"accSushiPerShare")," minus the ",(0,o.kt)("inlineCode",{parentName:"p"},"rewardDebt")),(0,o.kt)("h2",{id:"deposit"},"Deposit"),(0,o.kt)("p",null,"A depositor deposits LP tokens into a given pool to a given user. ",(0,o.kt)("inlineCode",{parentName:"p"},"user.amount"),"\nis increased according to the amount. The ",(0,o.kt)("inlineCode",{parentName:"p"},"rewardDebt")," is increased by ",(0,o.kt)("inlineCode",{parentName:"p"},"amount"),"\nadded times ",(0,o.kt)("inlineCode",{parentName:"p"},"pool.accSushiPerShare")," / ",(0,o.kt)("inlineCode",{parentName:"p"},"ACC_SUSHI_PRECISION")," to ensure that the\nuser does not gain rewards from the past."),(0,o.kt)("p",null,"The rewarder contract is called with the new lp token amount of the user. Only\nafterwards the lp tokens are transferred to the rewarder."),(0,o.kt)("h2",{id:"withdraw"},"Withdraw"),(0,o.kt)("p",null,"A user withdraws LP tokens from a given pool to a given address. ",(0,o.kt)("inlineCode",{parentName:"p"},"user.amount"),"\nis decreased according to the amount. The ",(0,o.kt)("inlineCode",{parentName:"p"},"rewardDebt")," is decreased by ",(0,o.kt)("inlineCode",{parentName:"p"},"amount"),"\nadded times ",(0,o.kt)("inlineCode",{parentName:"p"},"pool.accSushiPerShare")," / ",(0,o.kt)("inlineCode",{parentName:"p"},"ACC_SUSHI_PRECISION")," ."),(0,o.kt)("p",null,"The rewarder contract is called with the new lp token amount of the user. Only\nafterwards the lp tokens are transferred to the rewarder."),(0,o.kt)("h2",{id:"harvest"},"Harvest"),(0,o.kt)("p",null,"Allows a user to withdraw the pending amount of Sushi to a given address."),(0,o.kt)("p",null,"The pending amount is ",(0,o.kt)("inlineCode",{parentName:"p"},"user.amount")," times ",(0,o.kt)("inlineCode",{parentName:"p"},"accSushiPerShare")," /\n",(0,o.kt)("inlineCode",{parentName:"p"},"ACC_SUSHI_PRECISION")," - ",(0,o.kt)("inlineCode",{parentName:"p"},"user.rewardDebt"),"."),(0,o.kt)("p",null,"The rewardDebt needs to be increased to mark the withdrawal to ",(0,o.kt)("inlineCode",{parentName:"p"},"user.amount"),"\ntimes ",(0,o.kt)("inlineCode",{parentName:"p"},"accSushiPerShare")," / ",(0,o.kt)("inlineCode",{parentName:"p"},"ACC_SUSHI_PRECISION"),"."),(0,o.kt)("p",null,"A call is executed to the ",(0,o.kt)("inlineCode",{parentName:"p"},"rewarder")," with the function call of ",(0,o.kt)("inlineCode",{parentName:"p"},"onSushiReward"),"\ndefined by the interface below."),(0,o.kt)("h2",{id:"sushi-per-block"},"Sushi Per Block"),(0,o.kt)("p",null,"function sushiPerBlock() public view returns (uint256 amount) {"),(0,o.kt)("p",null,"amount \\= uint256(MASTERCHEF_SUSHI_PER_BLOCK)"),(0,o.kt)("p",null,".mul(masterChef.poolInfo(MASTER_PID).allocPoint) / masterChef.totalAllocPoint();"),(0,o.kt)("h2",{id:"external-rewards"},"External Rewards"),(0,o.kt)("p",null,"Projects that want to give out additional incentives can do so by creating a\ncontract that follows the interface below."),(0,o.kt)("p",null,"function onSushiReward(uint256 pid, address user, address recipient, uint256\nsushiAmount, uint256 newLpAmount) external;"),(0,o.kt)("p",null,"function pendingTokens(uint256 pid, address user, uint256 sushiAmount) external\nview returns (IERC20","[","]"," memory, uint256","[","]"," memory);"),(0,o.kt)("p",null,"The function onSushiReward is executed on the distribution of rewards with the\nuser and the amount of Sushi given out being specified. The responsibility of\nimplementing additional rewards now lies in the hands of the other project."),(0,o.kt)("h2",{id:"reward-token"},"Reward Token"),(0,o.kt)("p",null,"In Addition to the data currently provided to MasterChef on pool addition a\nrewarder is added, the new interface for add is, therefore:"),(0,o.kt)("p",null,"function add(uint256 allocPoint, IERC20 ","_","lpToken, IRewarder ","_","rewarder) public\nonlyOwner;"),(0,o.kt)("h2",{id:"harvest-from-mcv1"},"Harvest From MCV1"),(0,o.kt)("p",null,"Sushi has to be manually harvested from MCV1 to be able to withdrawn."),(0,o.kt)("p",null,"function harvestFromMasterChef () public {"),(0,o.kt)("p",null,"masterChef.deposit(MASTER_PID, 0);"),(0,o.kt)("p",null,"In the current draft, the exact pending amount has to be available for a\nwithdraw to succeed. This may cause issues because of rounding errors in case\nthere is only one user in the pool but also protects the user from withdrawing\nwithout their allocated SUSHI."))}u.isMDXComponent=!0}}]);